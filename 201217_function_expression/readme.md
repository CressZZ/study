# 함수 표현식 & 함수 선언식

## TL;DR
- 함수 표현식과 선언식의 가장 큰 차이는 호이스팅이 되느냐의 차이이다. 
- 함수 표현식과 선언식의 구별은 함수 자체에 있는게 아니라, 일반적인 `선언문`, `표현식`, `변수 호이스팅` 과 `함수 호이스팅` 이라는 용어에 있다. => `제일 혼란스러운 부분`
- 즉 함수 표현식, 함수 선언식이라는 것은 함수를 어떻게 정의 했는냐의 문제가 아니라 (함수를 정의하는 방법은 똑같다), 이게 변수할당 문구인지, 함수선언 문구인지의 차이가 되어 버리는 것이다. 
  
## 일단 무조건 읽어야 하는 참고사이트
https://velog.io/@jakeseo_me/%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8-%EA%B0%9C%EB%B0%9C%EC%9E%90%EB%9D%BC%EB%A9%B4-%EC%95%8C%EC%95%84%EC%95%BC-%ED%95%A0-33%EA%B0%80%EC%A7%80-%EA%B0%9C%EB%85%90-7-%ED%91%9C%ED%98%84%EC%8B%9D%EA%B3%BC-%EB%AC%B8Statement-%EB%B2%88%EC%97%AD-2xjuhvbal7  
https://ko.javascript.info/function-expressions

## 문 과 표현식
자바스크립트에는 크게 두가지 문법이 있다. 
- Statement
- Expression

### 표현식
- 표현식은 값 하나로 귀결되는 자바스크립트 코드 조각(snippet)이다. 
  
### 문장
- 문장은 기본적으로 문장은 무언가 수행합니다.
- 자바스크립트에서 문장은 값이 들어와야 할 곳에 들어갈 수 없다. 그래서 그들은 함수의 인자로도, 대입 연산의 값으로도, 연산자의 피연산자로도 사용될 수 없다.
- if, if-else, while, do-while, for, switch, for-in, with (deprecated), debugger, variable declaration

## 호이스팅
https://developer.mozilla.org/ko/docs/Web/JavaScript/Guide/Values,_variables,_and_literals


### 변수 호이스팅
#### var 의 경우

```js
console.log(a) //undefined
var a = 1;
```
- 자바스크립트 엔진은 처음 동작 하게 된면 var 로 정의한 변수명을 전부 맨 위로 끌고 온다. 
- 단, 할당된 값은 할당한 위치까지 엔진이 읽어 들어가야 제대로 할당을 한다. 
- 아무튼 맨처음 var a 라는 애가 있긴한데, 무슨 값인지 모르는 상태가 되는 것이다. 
- 자바스크립트 엔진 동작 -> var a 라는게 있구나. 오키 일단 맨위에 적어 놓자 -> 자이제 차레대로 스크립트를 실행하자 -> console.log(a) 를 실행하자 -> a라는 애가 있긴한데, 값은 없네... -> undefiend -> a 에 1이라는 값을 할당 하자.
- 이것이 호이스팅

#### let 의 경우
```js
console.log(a) //VM121:1 Uncaught SyntaxError: Identifier 'a' has already been declared
let a = 1;
```
- var 와 다르게 맨처음에 a 라는 변수를 정의 하지 않는다.

### 함수 호이스팅
```js
test();
function test(){
	console.log('test');
}
```
- 함수에 대한 모든 내용이 위로 올라간다.
- 자바스크립트 엔진 동작 -> test 라는게 있구나. 오키 일단 맨위에 test 라는 이름 뿐만 아니라 그내용도 적어 놓자 -> 자이제 차레대로 스크립트를 실행하자 -> test() 를 실행하자 -> 변수 호이스팅과는 다르게 test 의 내부도 다 적어 놓았지 -> console.log('test'); 실행 -> 음? 아까 전부 적어 논거네, 넘어가자.


## 함수 선언식
```js
test(); // 실행됨
function test() {
	console.log('hi~');
}
```
- 선언식은 호이스팅이 된다. (자바스크립트 엔진이 동작할때 ~ 어쩌구 ~ 저쩌구 ~ 아무튼 호이스팅 된다.)

## 함수 표현식
```js
test() // 실행안됨

var test = function (){
	console.log('hi~')
};

test();
```
- 표현식은 호이스팅이 안된다. 

## 함수 선언식과 함수 표현식의 비교
- 자 이제 위에 두개를 살펴보자. 일단 함수 표현식을 보자
- 함수 선언식과 함수 표현식은 함수를 정의한 문구 자체에 있는게 아니라, 변수에 할당을 했냐 안했냐의 차이로 받아들여야 이해하기 쉽다. 
- 실제로 함수내용을 정의한 문구에는 차이가 없다.
- 처음에는 표현식이 익명 함수라는 애기야? 라고 잘못 이해하기 쉽다. 
- 하지만 함수 표현식에서 변수에 할당하는 함수가 익명 함수가 아니어도 된다. 유명 함수여도 된다. 즉 아무런 차이가 없다는 것이다. 
- 그럼 함수 표현식이라는 것은 뭐냐. 바로 변수에 할당을 했다는 것이다. 
- 이게 어떤 차이를 만들어 내는가?
- 호이스팅이 안되지! 앞에 변수 호이스팅 섹션에 설명 한거 처럼 변수 명만 호이스팅 되고 나머지는 호이스팅이 안되지.
- 그럼 어떻게 되지? 함수 표현식(함수를 변수 할당)으로 만든 함수 이전에는 해당 함수를 쓸수가 없다. 
- 근데 왜 이걸 함수 표현식 / 함수 선언식이라고 하는 걸까?
- 표현식이라는 건 앞에 말했듯이 값으로 표현되는 스크립트의 조각을 말하는데
- 변수에 할당했다는 건 값을 할당 했다는 거니, 여기서 사용된 함수의 정의는 즉 값으로 귀결되는 하나의 표현식이라는 이야기
- 선언이라는건 문장이라는 의미인데, 함수 선언문은 그자체로는 값으로 표현될수 없는 그냥 함수를 정의한 문장이 된다. 
- 아니 좀더 정확히 말하면 함수를 정의한 함수 선언문은 그 자체로 값으로 표현될수 있다. 근데 이 정의한 내용을 값으로 사용하지 않았다 라는게 더 정확한 표현일듯.
- 예를 들면 `console.log(function test(){});` 을 실행하면 오류가 안난다. 이 이야기는 `function test(){}` 을 하나의 값으로 읽었다는 이야기이다. 그럼 이건 선언식이야? 표현식이야?
- 이건 함수를 표현식으로 사용했다! 라고 말할수 있다. 함수를 정의한 문장을 값으로서 사용했기 때문이다.  
- 다시 위 섹션의 예시로 돌아가보자. 표현식은 잘보면 함수 뒤에 세미콜론을 썼고, 선언문은 안썼다.
- 세미콜론이란건 원래 문장을 구별하기위에 문장 뒤에 사용하는 건데, block 형식의 문장({}) 뒤에는 세미콜론을 사용하지 않아도 되기때문이다. 
- 즉 함수 선언문은 진짜로 선언문(함수 선언문), 더욱이 블록 선언문이기 때문에 세미콜론을 안썼고, 
- 함수 표현식은 변수선언문 이기때문에 블럭 선언문이 아니며, 세미 콜론을 사용 해야 하는 것이다. 
- 이것도 잘생각해야 하는게 아니 위에서 함수 표현식이라고 했던 `console.log(function test(){});` 에서는 test함수에 세미콜론이 없는데? 라고 생각할수 있다. 
- 그러니까 함수 표현식 / 선언식에 따라 세미콜론이 있고 없고가 아니다. 세미콜론은 그냥 완전 다른 분야이다. 세미콜론은 여러 문장을 한줄에 슬때 문장을 구별하기 위해 사용하는 것이고, 블록 형식의 문장 뒤에는 세미콜론을 사용하지 않는다. 
- `console.log(function test(){});` 에서 `function test(){}`함수는 함수 선언문이고 블록 문장이며 세미 콜론이 없지만 궃이 따지자면 test 함수는 함수 표현식으로(값으로 사용되어진)만들어진 함수인 것이다.
- 선언문, 함수 선언식, 함수 표현식.... 햇갈린다.
- IIFE (Immediately Invoked Function Expression) 도 마찬가지로 표현식인데, 함수를 어떻게 정의 했냐에 따라 IIFE 가 되는게 아니라 
- 어떻게 사용했느냐에 따라 IIEF 가 되는것이다. 익명이든 기명이든 상관 없다는 이야기
- 함수를 즉시 실행하면 어떻게 되지? 즉시 값이 리턴 되지! 즉 IIFE 는 함수를 즉시 실행함으로서 그 문장 자체가 하나의 값으로 귀결되며 이는 곳 표현식이라고 할수 있는 것이다. 
 
```js
(function test(){return 1})(); // 이건 그냥 1 과 같은 표현식이다. 
```
- 즉 IIFE 도 표현식인 함수를 어찌어찌 해서 함수 표현식이 된게 아니라, 그냥 함수를 즉시실행함으로서 표현식이 된거고, 
- 일반적인 함수 표현식이라는 것도 일반적인 함수를 변수에 할당함으로서 자바스크립트의 문구중 변수할당 문구가 되며, 변수에 할당한 함수가 그냥 하나의 값처럼 쓰였기 때문에 그 함수를 함수 표현식이라 부르는 것이며
- 함수 선언식이라는 것도 일반적인 함수를 변수에 선언하지 않고 그냥 정의함으로서 자바스크립트의 문구중 함수선언 문구가 되어버리며, 함수자체가 호이스팅이된 함수 선언문이라고 부르는 것이다. 
- 즉 함수 표현식, 함수 선언식이라는 것은 함수를 어떻게 정의 했는냐의 문제가 아니라 (함수를 정의하는 방법은 똑같다), 이게 변수할당 문구인지, 함수선언 문구인지의 차이가 되어 버리는 것이다. 
- 좀 심화적으로는 기명함수 함수 표현식이라는 게 있는데 이것도 그냥 스코프의 문제이지 다른게 없다. 그냥 기명함수를 변수에 할당한거다. 
- (참고)[https://velog.io/@jakeseo_me/%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8-%EA%B0%9C%EB%B0%9C%EC%9E%90%EB%9D%BC%EB%A9%B4-%EC%95%8C%EC%95%84%EC%95%BC-%ED%95%A0-33%EA%B0%80%EC%A7%80-%EA%B0%9C%EB%85%90-7-%ED%91%9C%ED%98%84%EC%8B%9D%EA%B3%BC-%EB%AC%B8Statement-%EB%B2%88%EC%97%AD-2xjuhvbal7] 여기 진짜 정리 잘되어 있으니, 이곳을 항상 참고 하도록 하자

### 참조 
문 및 선언 : https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Statements
표현식과 연산자 :https://developer.mozilla.org/ko/docs/Web/JavaScript/Guide/Expressions_and_Operators

## 변수 할당
https://developer.mozilla.org/ko/docs/Web/JavaScript/Guide/Values,_variables,_and_literals

