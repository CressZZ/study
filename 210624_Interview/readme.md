# 면접 질문 리스트

https://sunnykim91.tistory.com/121
https://joontae-kim.github.io/2020/10/26/interview-question-fe/
https://devowen.com/276
https://blog.rhostem.com/posts/2020-04-13-fe-interview-handbook-js-2

# 노드 서버 경험이 있다고 하시는데 어떠한 프레임 워크를 썼나요?
익스프레스요!

# 어느분야를 담당하셨나요?
프론트 페이지요!

## ===(엄격한 동치연산잔) 과 ==(동치 연산자) 연산자의 차이는?
음...음..ㅋㅋㅋㅋㅋ

# 이벤트 루프란 무엇인가?
자바스크립트는 싱글 스레드 기반 언어이다. 함수를 실행하면 함수 호출이 스택에 순차적으로 쌓이고 스택의 맨위에서부터 아래로 한번에 하나의 함수만 처리 할 수 있다.  
하지만, 자바스크립트에는 이벤트 루프라는것을 통해 동시성을 지원한다. (동시에 일어나는 것이 아니라 동시에 일어나는 것처럼 보이게 하는것이다!) 
이벤트 루프는 콜 스택에서 실행 중인 게 있는지 확인하고, Event queue에 작업이 있는지 확인해서 콜스택이 비어있다면 이벤트큐 내의 작업이 콜스택으로 이동되어서 실행된다. 


# 콜 스택과 태스크 큐의 차이점은?
콜스택은 동기 어쩌고
테스크 큐는 비동기 어쩌고


# 브라우저에 url 치고 나서 동작하는거 가능한 상세하게
브라우저 주소창에 www.naver.com 치면  -> 네이버 서버를 찾아간다.     -> DNS(실제 서버가 어디에있는지 알고 있는 서버)가 연결해줄 곳을 찾음     -> (여기서 주소 앞에 https가 붙었다면 https방식으로 통신하겠다.)     -> 서버의 기본설정이 대부분 index.html되어 있어 서버에서 이파일을 클라이언트로 보냄    -> 브라우저는 텍스트로 이루어진 index.html 파일을 파싱한다.    -> 한줄한줄 읽으면서 DOM트리를 만들어나감.    -> 중간에 link태그를 만나 css요청이 발생하면, 요청과 응답과정을 거치고 css를 파싱함    -> CSS파싱이 끝나면 중단된 html을 다시읽고 DOM트리를 완성    -> 완성된 DOM트리와 CSSOM트리를 합쳐 Render Tree를 만들고 그린다.javascript는?    -> 중간에 HTML파서는 Script태그를 만나게 되면 javascript 코드를 실행하기 위해 파싱을 중단    -> 제어권한을 자바스크립트 엔진에게 넘기고, 자바스크립트 코드 또는 파일을 로드해서 파싱하고 실행

# 렌더링이란
렌더링 이란 서버로부터 HTML 파일을 받아 브라우저에 뿌려주는 과정 이고, 중요 렌더링 경로 (Critical Rendering Path)이란 브라우저에서 화면이 그려지기까지의 주요한 과정으로, 브라우저가 HTML, CSS, Javascipt를 화면에 픽셀로 변화하는 일련의 단계 를 말하며 이를 최적화하는 것은 렌더링 성능을 향상시킵니다.

## 간략한 렌더링 과정 
HTML 마크업을 Parsing(처리)하여 DOM 트리를 빌드한다. (“무엇을” 그릴지 결정한다.) (DOM 파싱)
CSS Parsing(처리)하여 CSSOM 트리를 빌드한다. (“어떻게” 그릴지 결정한다.) (CSS 파싱)
DOM 및 CSSOM 을 결합하여 렌더링 트리를 형성한다. (“화면에 그려질 것만” 결정) (Combination)
렌더링 트리에서 레이아웃을 실행하여 각 노드의 기하학적 형태를 계산한다. (“Box-Model” 을 생성한다.) (Layout)
개별 노드를 화면에 페인트한다.(or 래스터화) (Painting)
렌더링이 완료된 상태에서 사용자의 인터랙션에 의해 화면의 일부 영역이 변경된다면, 리플로우 또는 리페인트가 발생한다.
개략적인 과정 은 아래와 같다.

## 상세한 렌더링 과정 
웹 페이지 또는 어플리케이션에 대한 요청은 HTML 요청으로 시작됩니다.
서버는 응답 헤더 또는 데이터로 HTML을 반환합니다.
브라우저는 HTML을 분석하고 수신된 bytes를 DOM 트리로 변환하기 시작합니다.
브라우저는 스타일시트, 스크립트 또는 포함된 이미지 참조인 외부 자원에 대한 링크를 찾을때마다 요청을 시작합니다.
불러온 에셋을 다룰 때까지 나머지 HTML을 분석하는 작업하는 일부 요청은 중단되며 차단됩니다.
파싱은 CSS file을 만났을때도 계속되지만 특히 async 또는 defer 속성이 없는 <script> 태그를 만났을 경우에는 렌더링을 멈추고 HTML 파싱을 중단합니다. 비록 브라우저의 프리로드(preload) 스캐너가 이 과정을 가속화하지만 과도한 스크립트는 여전히 심각한 병목현상이 될 수 있습니다.
메인 스레드가 HTML, CSS를 분석하는 동안 Preload scanner는 스크립트와 이미지를 검색할 것이고 다운로드 받기 시작할 것입니다. 스크립트가 DOM 트리 구성 프로세스를 막지 않도록 보장하기 위해, 만약 Javascript 파싱 또는 실행 순서가 중요하지 않다면 async 또는 defer 속성을 추가해야 합니다.
CSS를 받기 위해 대기하는 것은 HTML 분석 또는 다운로딩은 막지 않지만 Javascript는 종종 HTML 요소에서 CSS 속성을 조회하는데 영향을 끼치기 때문에 막습니다.
브라우저는 CSSOM 구축 작업이 끝날때까지 요청을 만들고 DOM을 생성하는 HTML을 계속해서 분석합니다.
DOM과 CSSOM이 완료되면 브라우저는 렌더 트리를 생성하고 보여지는 컨텐츠를 위해 스타일을 계산합니다. (Layout)
레이아웃 은 너비, 높이 그리고 렌더 트리 안에서 모든 노드들의 위치를 결정하는 과정으로, 각 노드의 위치를 계산하기 위해 렌더 트리에서 레이아웃을 작동시키는 것입니다.
페이지 안에서 각 오브젝트의 크기와 위치에 대한 결정도 추가됩니다. 리플로우 는 페이지의 특정 부분 또는 전체 도큐먼트의 어떤 연속적인 크기와 위치에 대한 결정입니다.
렌더트리가 완료된 후 모든 렌더 트리 요소들에 대한 위치와 크기가 정의된 레이아웃이 만들어집니다. 일단 완료되면 레이지는 렌더링되거나 또는 화면에 ‘그려집니다(painted)’.

# 프로미스란 무엇인가?
Promise 객체는 비동기 작업이 맞이할 미래의 완료 또는 실패와 그 결과 값을 나타냅니다.

# Async,Await 란 무엇인가?
자바스크립트에서 비동기를 가독성 좋게 만들어 준다. 콜백 과 프로미스 then에서 벗어나게 해준다 

# babel, webpack, eslit 에 대해 간략하게 설명 해주세요
- babel은 컴파일러 / 폴리필 집합 / ESNext를 사용하게 해준다.
- webpack 은 번들러 / 빌드 과정을 통해 여러개의 파일을 하나로 합쳐 준다. 
- eslit은 문법 에러, 버그를 찾고 보고해주는 역할을 한다. 
- Prettier는 코드 스타일을 하나로 맞춰 준다. 


# 클로저가 무엇인가요?
클로저란 실행컨텍스트가 어쩌고...

# 호이스팅
호이스팅은 인터프리터가 자바스크립트 코드를 해석함에 있어서, Global 영역 또는 함수 영역 안에 대해서 주어진 선언들을 모두 끌어올려서 해당 유효 범위 최상단에 선언하는 것을 의미한다.

# 함수선언문과 함수표현식에 대해 설명 해주시고, 어떤 차이점이 있는지 알려주세요
선언문 : 호이스팅 됨
표현식 : 호이스팅 안됨

# 이벤트 델리게이션이 무엇인가요?
특정 요소 하나하나를 개별적으로 이벤트를 부여하는 것이 아니라, 하나의 부모에 이벤트를 등록하여 부모가 이벤트를 위임하는 방식을 이벤트 위임이라고 한다. 이 방법은 동적인 요소들에 대한 처리가 수월하며 이벤트 핸들러를 더 적게 등록해 주기 때문에 메모리도 절약할 수 있다.

# 이벤트 버블링과 캡처링에 대해
거의 모든 이벤트는 버블링 됩니다.
focus 이벤트와 같이 버블링 되지 않는 이벤트도 있습니다. 버블링 되지 않는 이벤트의 종류에 대해선 조금 후에 알아보겠습니다. 몇몇 이벤트를 제외하곤 대부분의 이벤트는 버블링 됩니다.

이벤트가 발생하면 이벤트가 발생한 가장 안쪽 요소가 '타깃 요소(event.target)'가 됩니다.

이벤트는 document에서 시작해 DOM 트리를 따라 event.target까지 내려갑니다. 이벤트는 트리를 따라 내려가면서 addEventListener(..., true)로 할당한 핸들러를 동작시킵니다. addEventListener(..., true)의 true는 {capture: true}의 축약형입니다.
이후 타깃 요소에 설정된 핸들러가 호출됩니다.
이후엔 이벤트가 event.target부터 시작해서 다시 최상위 노드까지 전달되면서 각 요소에 on<event>로 할당한 핸들러와 addEventListener로 할당한 핸들러를 동작시킵니다. addEventListener로 할당한 핸들러 중, 세 번째 인수가 없거나 false, {capture: false}인 핸들러만 호출됩니다.
각 핸들러는 아래와 같은 event 객체의 프로퍼티에 접근할 수 있습니다.

event.target – 이벤트가 발생한 가장 안쪽의 요소
event.currentTarget (=this) – 이벤트를 핸들링 하는 현재 요소 (핸들러가 실제 할당된 요소)
event.eventPhase – 현재 이벤트 흐름 단계(캡처링=1, 타깃=2, 버블링=3)
핸들러에서 event.stopPropagation()을 사용해 이벤트 버블링을 멈출 수 있습니다. 다만, 이 방법은 추천하지 않습니다. 지금은 상위 요소에서 이벤트가 어떻게 쓰일지 확실치 않더라도, 추후에 버블링이 필요한 경우가 생기기 때문입니다.

캡처링 단계는 거의 쓰이지 않고, 주로 버블링 단계의 이벤트만 다뤄집니다. 이렇게 된 데는 논리적 배경이 있습니다.

현실에서 사고가 발생하면 지역 경찰이 먼저 사고를 조사합니다. 그 지역에 대해 가장 잘 아는 기관은 지역 경찰이기 때문입니다. 추가 조사가 필요하다면 그 이후에 상위 기관이 사건을 넘겨받습니다.

이벤트 핸들러도 이와 같은 논리로 만들어졌습니다. 특정 요소에 할당된 핸들러는 그 요소에 대한 자세한 사항과 무슨 일을 해야 할지 가장 잘 알고 있습니다. <td>에 할당된 핸들러는 <td>에 대한 모든 것을 알고 있기 때문에 <td>를 다루는데 가장 적합합니다. 따라서 <td>를 다룰 기회를 이 요소에 할당된 핸들러에게 가장 먼저 주는 것입니다.

버블링과 캡처링은 '이벤트 위임(event delegation)'의 토대가 됩니다. 이벤트 위임은 강력한 이벤트 핸들링 패턴입니다. 다음 챕터에서 이를 다루도록 하겠습니다.

# event의 target 속성은 
event.target – 이벤트가 발생한 가장 안쪽의 요소
event.currentTarget (=this) – 이벤트를 핸들링 하는 현재 요소 (핸들러가 실제 할당된 요소)

# this
this는 자바스크립트 런타임 시에 바인딩이 이루어지는 실행 컨텍스트 중 하나로, 해당 함수가 실행되는 동안에 사용할 수 있으며 함수 호출 부분에서 this가 가리키는 것이 무엇인지를 확인할 수 있다. 때로는 복잡한 코드에서 암시적 바인딩에 의해 혼란스러운 경우가 많은데, 이런 문제를 해결하기 위해서 call이나 apply 같은 내장 유틸리티를 사용하여 명시적으로 바인딩을 해 준다.

# -> 화살표 함수는 무엇을 말하며 어떤 특징을 가지고 있는가요?

# 프로세스와 스레드의 차이
https://gmlwjd9405.github.io/2018/09/14/process-vs-thread.html


# http 프로토콜이란 ?
하이퍼 텍스트 트렌스퍼 프로토콜 입니다. 


# http 프로토콜중 header 의 content-type 이 의미 하는 것은?

# https 는 무엇인가요?


# 최근에 본 업무관련 서적이나 강의는 뭐가 있나요? 
에헤

# callback / promise  / async await
가장 먼저 나온 Callback은 비동기 처리를 구현하기 위해 만들어 졌다. 이 함수는 다른 함수에게 인자로 전달되어 어느 시점에 실행될 수 있도록 던져주는 함수이다. 하지만 콜백 지옥이라 불리는 중첩문이 발생하면서 에러처리 한계가 생기기 시작했고 이를 해결하기 위해 Promise가 나타났다.

Promise는 어떤 값이 생성 되었을 때 그 값을 대신하는 대리자이다. 비동기 연산이 종료된 이후에 그 결과 값이나 에러를 처리할 수 있도록 처리기를 연결하는 역할을 하는 객체이다. Promise 객체를 통해 성공, 실패, 오류에 따른 후속처리가 바로 가능해서 가독성도 좋고, 비동기 에러를 처리하기도 수월하다.

Async/await은 비동기 코드를 동기식으로 표현하는 더 나은 방법으로 ES2017에 등장하였다. Async와 await는 항상 같이 붙어 있어야 한다. await 모드는 Promise 객체를 받아 처리하고, 만약 비동기 함수가 아닌 동기적 함수라면 리턴 값을 그대로 받는다. Async 함수는 Promise 객체를 통해 비동기적으로 처리된 내용을 동기적인 코드 진행 순서로 보여주는 역할을 한다.